import type { DMMF } from "@prisma/generator-helper";
import { getDMMF } from "@prisma/internals";
import { existsSync, readFileSync, writeFileSync } from "node:fs";
import { resolve } from "node:path";
import type { SchemaInformation } from "../interfaces";

/**
 * Configuration interface for type mappings
 */
export interface PrismaExtractorConfig {
  mapTypes: Record<string, string>;
  outputType: "type" | "interface";
}

/**
 * Default type mappings from Prisma to TypeScript
 */
const DEFAULT_TYPE_MAPPINGS: Record<string, string> = {
  String: "string",
  Int: "number",
  Float: "number",
  BigInt: "bigint",
  Boolean: "boolean",
  DateTime: "Date",
  Json: "string",
  Decimal: "number",
  Bytes: "Buffer",
  Unsupported: "unknown",
};

/**
 * Loads the configuration file if it exists, otherwise returns defaults
 */
export function loadConfig(configPath?: string): PrismaExtractorConfig {
  const configFilePath =
    configPath || resolve(process.cwd(), "prisma-extractor.json");

  if (existsSync(configFilePath)) {
    try {
      const configContent = readFileSync(configFilePath, "utf-8");
      const userConfig = JSON.parse(
        configContent
      ) as Partial<PrismaExtractorConfig>;

      return {
        mapTypes: {
          ...DEFAULT_TYPE_MAPPINGS,
          ...userConfig.mapTypes,
        },
        outputType: userConfig.outputType || "interface",
      };
    } catch (error) {
      console.warn("‚ö†Ô∏è  Failed to load config file, using defaults:", error);
    }
  }

  return {
    mapTypes: DEFAULT_TYPE_MAPPINGS,
    outputType: "interface",
  };
}

/**
 * Generates a default configuration file
 */
export function generateConfigFile(configPath?: string): void {
  const configFilePath =
    configPath || resolve(process.cwd(), "prisma-extractor.json");
  const defaultConfig: PrismaExtractorConfig = {
    mapTypes: DEFAULT_TYPE_MAPPINGS,
    outputType: "interface",
  };

  try {
    writeFileSync(
      configFilePath,
      JSON.stringify(defaultConfig, null, 2),
      "utf-8"
    );
    console.log(`‚úÖ Configuration file created at: ${configFilePath}`);
    console.log("You can now edit this file to customize type mappings.");
  } catch (error) {
    console.error("üü• Failed to create config file:", error);
    throw new Error("Could not create configuration file.");
  }
}

/**
 * Extracts models and enums from a Prisma schema file.
 *
 * @param schemaPath - The absolute or relative path to the schema.prisma file.
 * @returns A promise that resolves to an object containing the extracted models and enums.
 * @throws An error if the schema file cannot be read or parsed.
 */
export async function extractSchema(
  schemaPath: string
): Promise<SchemaInformation> {
  try {
    const resolvedPath = resolve(schemaPath);
    if (!existsSync(resolvedPath)) {
      throw new Error(`Schema file not found at: ${resolvedPath}`);
    }

    const schema = readFileSync(resolvedPath, "utf-8");
    const dmmf = await getDMMF({ datamodel: schema });

    return {
      models: [...dmmf.datamodel.models],
      enums: [...dmmf.datamodel.enums],
    };
  } catch (error) {
    console.error("üü• Failed to extract schema:\n", error);
    throw new Error("Could not process Prisma schema.");
  }
}

function mapPrismaTypeToTsType(
  prismaType: string,
  config: PrismaExtractorConfig
): string {
  return config.mapTypes[prismaType] || prismaType;
}

export function generateTsInterfaces(
  models: DMMF.Model[],
  enums: DMMF.DatamodelEnum[],
  configPath?: string
): string {
  const config = loadConfig(configPath);
  let content = `// This file is auto-generated by sc-prisma-extractor.\n// Do not edit this file directly.\n\n`;

  // Generate Enums
  enums.forEach((enumDef: DMMF.DatamodelEnum) => {
    content += `export enum ${enumDef.name} {
`;
    enumDef.values.forEach((value: DMMF.EnumValue) => {
      content += `  ${value.name} = "${value.name}",
`;
    });
    content += `}

`;
  });

  // Generate Interfaces or Types
  models.forEach((model: DMMF.Model) => {
    const keyword = config.outputType === "type" ? "type" : "interface";
    const separator = config.outputType === "type" ? " =" : "";
    content += `export ${keyword} ${model.name}${separator} {
`;
    model.fields.forEach((field: DMMF.Field) => {
      const tsType = mapPrismaTypeToTsType(field.type, config);
      const isOptional = !field.isRequired;
      const isList = field.isList;
      content += `  ${field.name}${isOptional ? "?" : ""}: ${tsType}${
        isList ? "[]" : ""
      };
`;
    });
    content += `}

`;
  });

  return content;
}
